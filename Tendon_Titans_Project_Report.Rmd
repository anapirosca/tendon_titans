---
title: "Module 7 Project Report"
author: "Ana Pirosca, Jonah Kotzen, Katie Miller, Jessica Stolz"
date: '`r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(MuMIn)
library(tidyverse)
library(readr)
library(stringr)

```

## Introduction
How do muscles work when you're tired? Recognizing the fundamental role of length in muscle force generation, we will explore the impact of fatigue on the force-length relationship, particularly focusing on the upper limb's forearm flexors and their 3rd order lever system. While previous research has delved into the basics of muscle mechanics, the missing piece that makes our study relevant is a comprehensive exploration of how fatigue specifically influences the force-length relationship in the context of isometric muscle contractions, offering insights into practical scenarios like sustained muscle effort or prolonged physical activity [ANA WILL INSERT CITATION HERE].

Thus, we have two big questions: First, do the data about how much force your muscles can make match a certain pattern when you're pushing against something? Second, does the angle at which your muscles work change when you're tired compared to when you're not tired? Our investigation dives into the biomechanical aspects of muscle architecture, considering the mediation of force at the fiber level by crossbridges and the implications of lever configurations. 

## Methods
In order to answer the questions above, we obtained experimental data by fabricating and programming a load-cell data acquisition system (via Arduino) then we recorded isometric MVCs at 12 distinct elbow angle by moving the upper body in different locations relative to the goniometer that is secured to a table. In orer to obtain fatigued data, we eccentrically lowered heavy items with the same arm used in the initial experiment, waited two minutes, then performed the isometric MVCs again. 

In terms of how the class-wide data for an isometric MVC match a typical Force-Length relationship under control and fatigued conditions, we first normalized the data in order to make every student's relative force comparable. Then, we created a polynomial model in order to predict the maximum force at a specified angle under fatigued and non-fatigued conditions. In order to understand whether the differences observed in the maximum forces of the muscles were statistically significant, we conducted an ANOVA analysis.

## Software and Coding the Arduino
The Arduino was programmed using the following sketch...


HX711 scale;

void setup() {
  Serial.begin(115200);
  scale.begin(6, 7);
  scale.tare();
}

void loop() {
  float newReading = scale.get_units(10);
  Serial.println(newReading);
}

## Old Data 

```{r main, include=TRUE}

# Get all subdirectories (each representing a subject and state)
subdirs <- list.dirs(path = ".", full.names = FALSE, recursive = FALSE)

# Initialize an empty data frame to store the combined data
combined_data <- tibble()

# Process each subdirectory
for (subdir in subdirs) {
  # Extract the subject's name and state from the subdirectory name
  parts <- str_match(subdir, "^(.+) \\((Control|Fatigue)\\)$")
  name <- parts[, 2]
  state <- parts[, 3]

  # List all CSV files in the subdirectory
  file_paths <- list.files(path = subdir, pattern = "\\.csv$", full.names = TRUE)
  
  # Process each file
  for (file_path in file_paths) {
    # Extract the angle from the file name
    angle <- str_extract(basename(file_path), "_([0-9]+\\.[0-9]+)") %>% parse_number()
    
    # Read the CSV file without assuming the first row is a header
    data <- read_csv(file_path, col_names = FALSE, show_col_types = FALSE)
    
    # Assign a column name to the data and convert all values to absolute values
    data <- data %>% 
      rename(Measurement = 1) %>%
      mutate(across(everything(), abs))  # This assumes that all columns are measurements
    
    # Add the subject's name, state, and angle as new columns in the dataframe
    data <- data %>%
      mutate(
        Name = name,
        State = state,
        Angle = angle
      )
    
    # Combine with the existing combined_data
    combined_data <- bind_rows(combined_data, data)
  }
}

# View the combined data
print(combined_data)

```

# Jonah's Manipulation of the New_Data

## Meta Data
``` {r new, include=TRUE}

# Get all CSV files in the 'new_data' folder
file_paths <- list.files(path = "new_data", pattern = "\\.csv$", full.names = TRUE)

# Initialize an empty tibble to store the combined metadata
combined_metadata <- tibble(
  TeamName = character(),
  Person = character(),
  State = character(),
  Angle = double()
)

# Process each file
for (file_path in file_paths) {
  # Extract only the file name from the file path
  file_name <- basename(file_path)
  
# Extract metadata from the file name
parts <- str_match(file_name, "([a-zA-Z0-9]+)_(.+)_(control|fatigue)_(\\d+(\\.\\d+)?)\\.csv")
  
if (nrow(parts) > 0) {
  teamname <- parts[, 2]
  person <- parts[, 3]
  state <- parts[, 4]
  angle <- as.numeric(parts[, 5])  # Convert angle to numeric

    # Create a tibble with the extracted metadata
    metadata <- tibble(
      TeamName = teamname,
      Person = person,
      State = state,
      Angle = angle
    )
    
    # Combine with the combined_metadata tibble
    combined_metadata <- bind_rows(combined_metadata, metadata)
  }
}

# Print the combined metadata tibble
print(combined_metadata)

```



# Factoring in Force

```{r bug fix, include=TRUE}

force_data <- read.csv(file_path) %>% select(force)


```

```{r combined data, include = TRUE}

```

# Max Values - The Jonah Way
```{r max values , include=TRUE}

# Assuming 'combined_data' is your tibble with all the data
combined_data <- combined_data %>%
  # Ensure all measurement values are absolute values
  mutate(across(starts_with("Measurement"), abs)) %>%
  # Group by Name, State, and Angle to calculate max within each group
  group_by(Name, State, Angle) %>%
  # Calculate the max measurement for each group
  mutate(Max_Measurement = max(Measurement, na.rm = TRUE)) %>%
  # Calculate the ratio of each measurement to the max measurement
  mutate(Ratio = Measurement / Max_Measurement) %>%
  # Ungroup the data if you want to perform other ungrouped operations later
  ungroup()

# View the modified data
print(combined_data)

```

## TEST 
```{r, comparing isometric MVCs}
#finding the maximum Force (Fmax) and the angle it occurs
normF <- c(#gonna put values in here :])%>%
  ang[which.max(normF)]
  
#modeling for a better Fmax
poly.m2 <- lm(normF~poly(ang,2)) 
poly.m3 <- lm(normF~poly(ang,3)) 
poly.m4 <- lm(normF~poly(ang,4))
AICc(poly.m2,poly.m3,poly.m4)

x.pred <- seq(45,157.5,length.out = 1000)
```

# Max Values - The Chris Way

```{r normal values , include=TRUE}


# Assuming 'combined_data' is the dataframe containing all the measurements

# Normalize the data by dividing each measurement by the max measurement for each angle, name, and state
normalized_data <- combined_data %>%
  group_by(Name, State, Angle) %>%
  mutate(Ratio = abs(Measurement) / max(abs(Measurement), na.rm = TRUE)) %>%
  ungroup()

# Define the range of angles to predict over
x.pred <- seq(min(normalized_data$Angle), max(normalized_data$Angle), length.out = 1000)
```

# BIG ERROR - Fitting Polynomial Models
```{r fitting poly, include=TRUE}

# Fit polynomial models and calculate AICc for model selection
best_models <- normalized_data %>%
  group_by(Name, State) %>%
  nest() %>%
  mutate(
    model_fits = map(data, ~ {
      data <- .x
      if (n_distinct(data$Angle) > 2) {
        model2 <- lm(Ratio ~ poly(Angle, 2), data = data)
        model3 <- lm(Ratio ~ poly(Angle, 3), data = data)
        model4 <- lm(Ratio ~ poly(Angle, 4), data = data)
        tibble(
          model2 = list(model2),
          model3 = list(model3),
          model4 = list(model4),
          aicc2 = AICc(model2),
          aicc3 = AICc(model3),
          aicc4 = AICc(model4)
        )
      } else {
        tibble(
          model2 = list(NA),
          model3 = list(NA),
          model4 = list(NA),
          aicc2 = NA_real_,
          aicc3 = NA_real_,
          aicc4 = NA_real_
        )
      }
    }),
    best_aicc = pmap_dbl(model_fits, ~ min(c(...), na.rm = TRUE)),
    best_model = pmap(model_fits, ~ .x[[which.min(c(..., na.rm = TRUE))]])
  ) %>%
  select(Name, State, best_model)

# Predict the ratio for each angle using the best fitting model
predictions <- map2(
  best_models$best_model, 
  best_models$State, 
  ~ if (!is.na(.x)) augment(.x, newdata = data.frame(Angle = x.pred)) else tibble(Angle = x.pred, .fitted = NA_real_)
)

# Combine predictions with the best_models dataframe
best_models <- best_models %>%
  mutate(predictions = predictions)

# Extracting the angles of maximum ratio
theta_max <- best_models %>%
  mutate(theta_max = map_dbl(predictions, ~ if (all(is.na(.x$.fitted))) NA_real_ else .x$Angle[which.max(.x$.fitted)]))

# Calculate the mean shift and SEM of theta_max
shifts <- theta_max %>%
  group_by(Name) %>%
  summarize(
    control_theta_max = theta_max$theta_max[State == "Control"],
    fatigue_theta_max = theta_max$theta_max[State == "Fatigue"],
    shift = fatigue_theta_max - control_theta_max,
    .groups = "drop"
  ) %>%
  summarize(
    mean_shift = mean(shift, na.rm = TRUE),
    se_shift = sd(shift, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(shifts)


```
>>>>>>> Stashed changes






## Results

## Discussion

## Author Contributions
Jonah - Methods 
Katie - Data collection + set up 
Ana - Methods 
Jess 
